New Pattern: Partition DP
- Solve a problem in a particular way.
- Example:
    - (1+2+3)*5
    - (1+2) + (3*5)
- Solve in a different ways and identify the best possible way

Problem 01: Matrix Chain Multiplication
ABC
A -> 10 * 30
B -> 30 * 5
C -> 5 * 60

AB
=>
A = 10 * 30
B = 30 * 5

To multiply AB matrix, total number of operations for AB is = 10 * 30 * 5 = 1500

A:
1 2
3 1

B:
2
3

What are ways to multiply ABC:
1) (AB)C
    => (10 * 30 * 5) + (10 * 5 * 60) = 1500 + 3000 = 4500 operations
    AB gives resultant matrix size = 10 * 5 size matrix

2) A(BC)
    => (30 * 5 * 60) + (10 * 30 * 60) = 9000 + 18000 = 27000 operations
    BC gives resultant matrix size = 30 * 60

The minimal operations required is 4500 ((AB)C)

Question like:
- Given the N matrix dimensions, tell me the minimum cost to multiply them to a single one.
- if I take 4 matrices: ABCD
    * Can be A(B(CD)) or (AB)(CD) or (A(BC)D) .... etc


 Given
 arr[] -> [10,20,30,40,50]
 Array has (n-1) matrix dimensions, where n = 5

 A -> 10 * 20
 B -> 20 * 30
 C -> 30 * 40
 D -> 40 * 50

 1st matrix -> A[0] * A[1]
 2nd matrix -> A[1] * A[2]
 3rd matrix -> A[2] * A[3]
 4th matrix -> A[3] * A[4]

ith matrix -> A[i-1] * A[i]

Tell me minimum number of operations required in order to multiple these matrices in a different ways.

===> Rules
1) Start with entire block or array, always represent them with i and j (f(i,j)), where i is the start index and j is the end index.
2) Base case
3) Try all partitions:
    * Run a loop to try all partitions.
4) Return the best possible among 2 partitions.


[10, 20, 30, 40, 50]
      A   B   C   D
      i           j
      1           n-1

f(1,4) -> solve 1,4 of matrix chain multiplication: return the minimum multiplications to multiply matrix 1 to 4.
Base case: Number of operation is 0 if we have a single matrix and we can't perform number of operation for that.
if(i == j) return 0;

k = run a for loop from (i -> (j-1))
and we have recursive calls : f(i, k), f(k+1, j)

k = (i to (j-1))
k = (1 to 3)
    - k = 1, f(1, 1), f(2, 4)
    - k = 2, f(1, 2), f(3, 4)
    - k = 3, f(1, 3), f(4, 4)

k

Problem: Matrix Chain Multiplication:
f(i,j) {
    if(i == j) return 0;

    mini = 1e9;
    for(k -> i to (j-1)) {
        steps = (arr[i-1] * arr[k] * arr[j]) + f(i, k) + f(k+1, j);
        mini = min(mini, steps);
    }

    return mini;
}

TC :O(n * n * n) = ~O(n^3)
    where first two n's are i, j and it uses an array, and last n is the for every (i, j), we use for loop inside the function
    and it take approximately n or less than of it.
SC: O(n * n) [cache 2D array] + O(n)[recursion] = O(n^2)

=====> Recursion to Memoization
- Identify the overlapping sub-problems

=====> Tabulation Approach:
Convert to Dynamic Programming (Bottom-up Approach)
1) Copy base cases
2) Write down changing states
    i, j
3) Copy the recurrences

